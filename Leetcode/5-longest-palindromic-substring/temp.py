class Solution:
    def longestPalindrome(self, s: str) -> str:
        """

        :param s:
        :return: наибольший палиндром в s

        1: Палиндром (aBa) (aBba)
            - Просто идем по серединам(левый от середины(сначала правый добавляем))
            и если палиндромность нарушена 2 раза, то следующий шаг
            b - ba - aba - abac - eabac(следующая итерация)
            b - bb - abb - abbc
            Прекращаем только когда нарушена полиндромность 2 раза


            Заводим 2 разных цикла:
                -Один идет по четным полиндром
                -Второй по нечетным
                -если ошибка, то прерырваем
                -если больше res, то заменяем
        2:
            Как зная предыдущий палиндром найти палиндром побольше?

            Я решал инвариантом, а как решить это при помощи динамического программирования?
            dynamic - список где каждый индекс i будет обозначать наибольший палиндром в s[:i+1]
            Тогда у нас есть выбор:
                Либо начинать новый палиндром,  либо продожать старый

            dynamic - список, где каждый элемент i обозначает наиб палиндром, заканчивающийся на i
            Пусть мы пытаемся найти i+1, зная end, start
            - Пытаемся расширить предыдущий, сравнив текущее с start -1
            - Пытаемся хотя бы сохранить длину сравнив текущее с start+1
            - (Если предыдущий палиндром имеет конец в i(его длина 1), то сравниваем пред. элемент с текущим,
              тогда получим палиндром длины 2)
              Попробуем сравнивать текущее с start
            - Создаем новый палиндром если ни один из вариантов не прошел

            Нам надо каким-то образом знать что в середине, ведь
            bbb -> bbbb (верно) и bab -> babb (неверно3)


            dynamic содердит кортежи (start, end) -> Можно обойтись только start т.к. end уже известен

            Знать начало и конец не достаточно, так как abba/aaa a (a) не можем определить по началу и концу

        3:
            матрица размера NxN идем по диагоналям,
            на первой диагонали записываем сами буквы
            Пусть мы находим в точке [r, c], тогда если s[r] == s[c], то добавляем 2 к значению и записываем
            max( 2*(s[r]==s[c]), matr[r-1][s], matr[r][s-1])

            Ошибка в том, что нельзя просто так к диагонали добавлять, потому что она может
            быть где-то убер далеко



            Надо как-то заполнять первые 2 ряда...
        """
        n = len(s)
        dynamic = [['']*n for i in range(n)]
        for offset in range(0, n):
            for row in range(n-offset):
                col = row+offset
                if offset == 0:
                    dynamic[row][col] = s[row]
                else:
                    diag = dynamic[row+1][col-1]
                    if s[row] == s[col] and (diag or offset < 2):
                        diag = s[row] + diag + s[col]
                        dynamic[row][col] = diag
        return dynamic[0][-1]